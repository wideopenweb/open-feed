<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Repo Browser</title>
    <style>
        :root{--bg:#0f1724;--panel:#0b1220;--muted:#94a3b8;--accent:#6ee7b7;--card:#0b1726}
        html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;color:#e6eef6;background:linear-gradient(180deg,var(--bg),#051225)}
        .wrap{display:flex;height:100vh;gap:12px;padding:16px;box-sizing:border-box}
        .sidebar{width:360px;background:linear-gradient(180deg,var(--panel),#071427);border-radius:8px;padding:12px;box-shadow:0 6px 18px rgba(2,6,23,.6);overflow:auto}
        .main{flex:1;background:linear-gradient(180deg,var(--card),#071427);border-radius:8px;padding:12px;overflow:auto}
        .inputs{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px}
        input,button,select{background:#041226;border:1px solid rgba(255,255,255,.04);color:var(--muted);padding:8px;border-radius:6px}
        button{cursor:pointer;color:#05201a;background:linear-gradient(180deg,var(--accent),#2de1b0);border:none}
        ul.tree{list-style:none;padding-left:6px;margin:0}
        li.item{padding:6px 8px;border-radius:6px;margin:4px 0;display:flex;justify-content:space-between;align-items:center;cursor:pointer}
        li.item.folder{background:linear-gradient(180deg,rgba(255,255,255,.02),transparent)}
        li.item.file{background:transparent}
        .meta{font-size:12px;color:var(--muted)}
        .viewer{height:100%;display:flex;flex-direction:column}
        .viewer .title{font-weight:600;color:#e6f6ef;margin-bottom:8px}
        .viewer .content{flex:1;overflow:auto;background:#021220;border-radius:6px;padding:12px;color:#dbeef5}
        pre{white-space:pre-wrap;word-break:break-word}
        a.link{color:var(--accent);text-decoration:none}
        .small{font-size:12px;color:var(--muted)}
        .controls{display:flex;gap:8px;align-items:center;margin-bottom:8px}
    </style>
    <!-- Marked for Markdown rendering and highlight.js for code highlighting -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet"
                href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
</head>
<body>
    <div class="wrap">
        <!-- Left sidebar removed. Main viewer occupies full layout. -->

        <main class="main">
            <div class="viewer">
                    <div class="title" id="fileTitle">No file selected</div>
                    <div class="meta small" id="fileMeta"></div>
                    <div id="status" class="small">Status messages will appear here.</div>
                    <div class="content" id="fileContent">Select a file in the tree to preview it here.</div>
            </div>
        </main>
    </div>

    <script>
        // GitHub Copilot: repo-browser single-file implementation (sidebar removed)
        const params = new URLSearchParams(location.search);
        let owner = params.get('owner') || 'octocat';
        let repo = params.get('repo') || 'Hello-World';
        const token = params.get('token') || '';
        const statusEl = document.getElementById('status');
        const fileTitle = document.getElementById('fileTitle');
        const fileContent = document.getElementById('fileContent');
        const fileMeta = document.getElementById('fileMeta');

        function setStatus(text, isError = false) {
            statusEl.textContent = text;
            statusEl.style.color = isError ? '#ffb4b4' : '';
        }

        function apiFetch(url, opts = {}) {
            const headers = opts.headers || {};
            headers['Accept'] = 'application/vnd.github.v3+json';
            if (token) headers['Authorization'] = 'token ' + token;
            return fetch(url, {...opts, headers})
                .then(async res => {
                    if (!res.ok) {
                        const text = await res.text().catch(()=>res.statusText);
                        throw new Error(res.status + ' ' + res.statusText + (text ? ' ‚Äî ' + text.slice(0,400) : ''));
                    }
                    return res.json();
                });
        }

        // decode base64 from API into UTF-8 string
        function decodeBase64ToUtf8(b64) {
            try {
                const binary = atob(b64.replace(/\s/g, ''));
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
                return new TextDecoder().decode(bytes);
            } catch(e) {
                // fallback
                return atob(b64);
            }
        }

        function createListItem(entry, parentPath) {
            const li = document.createElement('div');
            li.className = 'item ' + (entry.type === 'dir' ? 'folder' : 'file');
            li.dataset.path = entry.path;
            li.innerHTML = `
                <div style="display:flex;gap:8px;align-items:center">
                    <span style="opacity:.85">${entry.type === 'dir' ? 'üìÅ' : 'üìÑ'}</span>
                    <div>
                        <div style="font-weight:600;color:#e6f5ee">${entry.name}</div>
                        <div class="meta">${entry.type === 'dir' ? 'Directory' : (entry.size ? (Math.round(entry.size/1024)+' KB') : '')}</div>
                    </div>
                </div>
                <div style="opacity:.7;font-size:12px">${entry.type==='dir' ? 'Expand' : 'Open'}</div>
            `;
            li.addEventListener('click', async (e) => {
                e.stopPropagation();
                if (entry.type === 'dir') {
                    if (li._loaded) {
                        const child = li.querySelector('ul');
                        if (child) child.remove();
                        li._loaded = false;
                        return;
                    }
                    try {
                        li._loading = true;
                        setStatus('Loading directory ' + entry.path + '...');
                        const data = await apiFetch(`https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(entry.path)}`);
                        renderDirectoryUnder(li, data);
                        li._loaded = true;
                        setStatus('Directory loaded.');
                    } catch (err) {
                        setStatus('Failed to load directory: ' + err.message, true);
                    } finally {
                        li._loading = false;
                    }
                } else {
                    // file
                    openFile(entry);
                }
            });
            return li;
        }

        function renderDirectory(entries) {
            const root = document.getElementById('treeRoot');
            if (!root) return;
            root.innerHTML = '';
            const ul = document.createElement('ul');
            ul.className = 'tree';
            entries.sort((a,b) => (a.type === b.type) ? a.name.localeCompare(b.name) : (a.type === 'dir' ? -1 : 1));
            entries.forEach(entry => {
                const itemLi = createListItem(entry);
                const wrapper = document.createElement('li');
                wrapper.style.listStyle = 'none';
                wrapper.appendChild(itemLi);
                ul.appendChild(wrapper);
            });
            root.appendChild(ul);
        }

        function renderDirectoryUnder(parentEl, entries) {
            const ul = document.createElement('ul');
            ul.className = 'tree';
            entries.sort((a,b) => (a.type === b.type) ? a.name.localeCompare(b.name) : (a.type === 'dir' ? -1 : 1));
            entries.forEach(entry => {
                const itemLi = createListItem(entry);
                const wrapper = document.createElement('li');
                wrapper.style.listStyle = 'none';
                wrapper.appendChild(itemLi);
                ul.appendChild(wrapper);
            });
            parentEl.appendChild(ul);
        }

        async function openFile(entry) {
            try {
                setStatus('Loading file ' + entry.path + '...');
                fileTitle.textContent = entry.path;
                fileMeta.textContent = `${entry.size ? entry.size + ' bytes' : ''} ‚Ä¢ ${entry.type}`;
                // Use the API to get content (base64) if available; otherwise fetch download_url
                let data;
                if (entry.content) {
                    data = entry;
                } else {
                    data = await apiFetch(`https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(entry.path)}`);
                }
                const b64 = data.content || '';
                const decoded = decodeBase64ToUtf8(b64);
                renderContent(entry.name, decoded);
                setStatus('File loaded.');
            } catch (err) {
                setStatus('Failed to load file: ' + err.message, true);
            }
        }

        function renderContent(filename, content) {
            const lower = filename.toLowerCase();
            if (lower.endsWith('.md') || lower.endsWith('.markdown')) {
                const html = marked.parse(content || '');
                fileContent.innerHTML = html;
                document.querySelectorAll('pre code').forEach((block) => {
                    hljs.highlightElement(block);
                });
            } else if (/\.(html?|htm)$/.test(lower)) {
                // show as rendered HTML but also provide source toggle
                fileContent.innerHTML = content || '';
            } else if (/\.(png|jpg|jpeg|gif|svg|webp)$/.test(lower)) {
                // attempt to render image by creating data URL if possible.
                if (/^data:/.test(content.trim())) {
                    fileContent.innerHTML = `<img src="${content.trim()}" style="max-width:100%;height:auto">`;
                } else {
                    // For images, better to fetch raw via download_url ‚Äî try to find a raw URL
                    fileContent.innerHTML = `<div class="small">Image preview not available. Open raw file on GitHub.</div>`;
                }
            } else {
                // code / text
                const escaped = escapeHtml(content || '');
                fileContent.innerHTML = `<pre><code>${escaped}</code></pre>`;
                // try to highlight by language hint
                document.querySelectorAll('pre code').forEach((block) => {
                    hljs.highlightElement(block);
                });
            }
        }

        function escapeHtml(s) {
            return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
        }

        async function loadPosts(owner, repo) {
            if (!owner || !repo) {
                setStatus('Owner and repo required', true);
                return;
            }
            // We specifically load the `posts` directory and render each post's README
            const postsPath = 'posts';
            setStatus('Loading posts directory...');
            fileTitle.textContent = 'Posts';
            fileMeta.textContent = '';
            fileContent.innerHTML = '<div class="small">Loading posts... please wait.</div>';
            try {
                const repoApi = `https://api.github.com/repos/${owner}/${repo}`;
                const baseUrl = `${repoApi}/contents`;
                const postsUrl = `${baseUrl}/${encodeURIComponent(postsPath)}`;
                const posts = await apiFetch(postsUrl);
                if (!Array.isArray(posts)) {
                    setStatus('`posts` is not a directory or is missing.', true);
                    fileContent.innerHTML = '<div class="small">No `posts` directory found in the repository.</div>';
                    return;
                }

                // find directories under posts
                let dirs = posts.filter(p => p.type === 'dir');
                // fetch latest commit for each directory so we can sort newest ‚Üí oldest
                try {
                    const dated = await Promise.all(dirs.map(async (d) => {
                        try {
                            const commits = await apiFetch(`${repoApi}/commits?path=${encodeURIComponent(postsPath + '/' + d.name)}&per_page=1`);
                            const latest = Array.isArray(commits) && commits[0] && commits[0].commit ? (commits[0].commit.author?.date || commits[0].commit.committer?.date) : null;
                            return {...d, _latestCommitDate: latest ? new Date(latest).toISOString() : null};
                        } catch (e) {
                            return {...d, _latestCommitDate: null};
                        }
                    }));
                    // sort by latest commit date descending (newest first); fallback to name
                    dated.sort((a,b) => {
                        if (a._latestCommitDate && b._latestCommitDate) return b._latestCommitDate.localeCompare(a._latestCommitDate);
                        if (a._latestCommitDate) return -1;
                        if (b._latestCommitDate) return 1;
                        return a.name.localeCompare(b.name);
                    });
                    dirs = dated;
                } catch (e) {
                    // if commit lookups fail, continue with unsorted dirs
                }
                if (dirs.length === 0) {
                    setStatus('No post directories found under `posts`.', true);
                    fileContent.innerHTML = '<div class="small">No post directories found under `posts`.</div>';
                    return;
                }

                // Build a combined view: each post section contains rendered README
                const container = document.createElement('div');
                container.style.display = 'flex';
                container.style.flexDirection = 'column';
                container.style.gap = '18px';

                for (const dir of dirs) {
                    setStatus(`Loading post: ${dir.name}...`);
                    try {
                        const dirUrl = `${baseUrl}/${encodeURIComponent(postsPath)}/${encodeURIComponent(dir.name)}`;
                        const dirContents = await apiFetch(dirUrl);
                        // find README (case-insensitive)
                        const readmeFile = dirContents.find(f => /^readme(\.(md|markdown))?$/i.test(f.name));
                        const section = document.createElement('section');
                        section.style.background = 'linear-gradient(180deg, rgba(255,255,255,0.01), transparent)';
                        section.style.padding = '10px';
                        section.style.borderRadius = '6px';

                        const header = document.createElement('div');
                        header.style.display = 'flex';
                        header.style.justifyContent = 'space-between';
                        header.style.alignItems = 'center';
                        header.style.marginBottom = '6px';

                        const titleDiv = document.createElement('div');
                        titleDiv.style.fontWeight = '700';
                        titleDiv.textContent = dir.name;

                        const badge = document.createElement('div');
                        badge.className = 'small';
                        badge.style.opacity = '0.9';
                        badge.style.background = 'rgba(255,255,255,0.02)';
                        badge.style.padding = '4px 8px';
                        badge.style.borderRadius = '999px';
                        badge.style.fontSize = '12px';
                        badge.style.color = 'var(--muted)';
                        if (dir._latestCommitDate) {
                            const d = new Date(dir._latestCommitDate);
                            badge.textContent = d.toLocaleDateString(undefined, {year: 'numeric', month: 'short', day: 'numeric'});
                            badge.title = d.toISOString();
                        } else {
                            badge.textContent = '';
                        }

                        header.appendChild(titleDiv);
                        header.appendChild(badge);
                        section.appendChild(header);

                        if (!readmeFile) {
                            const note = document.createElement('div');
                            note.className = 'small';
                            note.textContent = 'No README found for this post.';
                            section.appendChild(note);
                            container.appendChild(section);
                            continue;
                        }

                        // fetch the README file object (includes base64 content)
                        const fileData = await apiFetch(readmeFile.url);
                        const decoded = decodeBase64ToUtf8(fileData.content || '');
                        const wrapper = document.createElement('div');
                        // render markdown
                        const html = marked.parse(decoded || '');
                        wrapper.innerHTML = html;
                        // highlight code blocks within this wrapper
                        wrapper.querySelectorAll('pre code').forEach(block => hljs.highlightElement(block));

                        section.appendChild(wrapper);
                        container.appendChild(section);
                    } catch (innerErr) {
                        const errNote = document.createElement('div');
                        errNote.className = 'small';
                        errNote.style.color = '#ffb4b4';
                        errNote.textContent = `Failed to load post ${dir.name}: ${innerErr.message}`;
                        container.appendChild(errNote);
                    }
                }

                fileContent.innerHTML = '';
                fileContent.appendChild(container);
                setStatus('Posts loaded.');
            } catch (err) {
                setStatus('Failed to load posts: ' + err.message, true);
                fileContent.innerHTML = `<div class="small" style="color:#ffb4b4">Failed to load posts: ${err.message}</div>`;
            }
        }

        // Auto-load posts using query params or defaults
        loadPosts(owner, repo);

        // inputs and sidebar removed; posts are auto-loaded from URL params or defaults
    </script>
</body>
</html>